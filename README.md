# <img src="https://postfiles.pstatic.net/MjAyNDA4MDVfNzgg/MDAxNzIyODQ0ODc2Mjc2.wdvKIMF3dTPJc5pT93d1A_FXWuiodKYX64naEKGec-Yg.65BL_WoiWxmgkDLHxz6pjUm1WNmCUH6x7qYakbskAsEg.PNG/gonggan02.png?type=w773" style="width:40px; vertical-align: middle;"> Gong-Gan

Gong-Gan은 여러 명의 사용자가 협업할 수 있는 공간을 제공하는 크롬 익스텐션입니다!<br>
실시간 클릭 이벤트, 스크롤 이벤트, 음성 채팅, 공유 캔버스를 이용해 로컬 브라우저에서 다른 사용자와 상호작용 할 수 있습니다.<br>
Gong-Gan을 통해 여러 사용자와 원활하게 협업하고 소통하세요!
<br>

# 🔨 Tech Stacks

### | Frontend

![Static Badge](https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=JavaScript&logoColor=white)
![Static Badge](https://img.shields.io/badge/React-20232A?style=for-the-badge&logo=react&logoColor=61DAFB)
![Static Badge](https://img.shields.io/badge/Tailwind_CSS-38B2AC?style=for-the-badge&logo=tailwind-css&logoColor=white)

### | Server

![Static Badge](https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=JavaScript&logoColor=white)
![Static Badge](https://img.shields.io/badge/node.js-%2343853d?style=for-the-badge&logo=node.js&logoColor=white)

### | Real-time

![Static Badge](https://img.shields.io/badge/websocket-lightpink.svg?logo=data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMCIgd2lkdGg9IjM2MC4wMDAwMDBwdCIgaGVpZ2h0PSIyNzIuMDAwMDAwcHQiIHZpZXdCb3g9IjAgMCAzNjAuMDAwMDAwIDI3Mi4wMDAwMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgoKPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsMjcyLjAwMDAwMCkgc2NhbGUoMC4xMDAwMDAsLTAuMTAwMDAwKSIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIj4KPHBhdGggZD0iTTIzMCAyNDg1IGwyMjUgLTIyNSA0NjAgMCA0NjAgMCAxNjMgLTE2MyAxNjIgLTE2MiAtMjQwIC0yNDAgLTI0MCAtMjQwIC0xNjUgMTY1IC0xNjUgMTY1IDAgMTI3IDAgMTI4IC0yMjAgMCAtMjIwIDAgMCAtMjIyIDAgLTIyMyAzODcgLTM4MiAzODggLTM4MiA3OCA3NyA3NyA3NyAxNTMgLTE1MyAxNTIgLTE1MiAzMTUgMCAzMTUgMCAtMzEwIDMxMCAtMzEwIDMxMCA4MSA4MSA4MCA4MCAzMTAgLTMwNCAzMDkgLTMwNSAzIDMwNiAyIDMwNiAtMTUwIDE1MSBjLTgyIDgzIC0xNTAgMTU1IC0xNTAgMTYwIDAgNiAzNCA0NCA3NSA4NSBsNzUgNzUgLTM4NyAzODcgLTM4OCAzODggLTc3NSAwIC03NzUgMCAyMjUgLTIyNXoiLz4KPHBhdGggZD0iTTI0OTAgMjA5NSBsLTE1NSAtMTU1IDE4OCAtMTg4IDE4NyAtMTg3IDAgLTQ0MyAwIC00NDIgMjIwIDAgMjIwIDAgMCA1MzggMCA1MzcgLTI0OCAyNDggYy0xMzYgMTM2IC0yNDkgMjQ3IC0yNTIgMjQ3IC0zIDAgLTc1IC03MCAtMTYwIC0xNTV6Ii8+CjxwYXRoIGQ9Ik0xMDYyIDY2NyBsLTE1MiAtMTUyIDI1MyAtMjUzIDI1MiAtMjUyIDEwODggMCBjNTk4IDAgMTA4NyAzIDEwODcgNyAwIDMgLTk4IDEwMiAtMjE3IDIxOSBsLTIxOCAyMTMgLTc3OSAxIC03ODAgMCAtMTg2IDE4NSBjLTEwMiAxMDIgLTE4OCAxODUgLTE5MCAxODUgLTMgMCAtNzQgLTY5IC0xNTggLTE1M3oiLz4KPC9nPgo8L3N2Zz4=&style=for-the-badge&logoColor=black)
![Static Badge](https://img.shields.io/badge/webrtc-mediumslateblue?style=for-the-badge&logo=webrtc&logoColor=white)

### | Build & Deployment

![Static Badge](https://img.shields.io/badge/Vite-B73BFE?style=for-the-badge&logo=vite&logoColor=FFD62E)
![Static Badge](https://img.shields.io/badge/Render-46E3B7?style=for-the-badge&logo=render&logoColor=white)

### | Test

![Static Badge](https://img.shields.io/badge/jest-%23944058?style=for-the-badge&logo=jest)
![Vitest](https://img.shields.io/badge/Vitest-%2344A833.svg?style=for-the-badge&logo=vitest&logoColor=white)
![Static Badge](https://img.shields.io/badge/ngrok-140648?style=for-the-badge&logo=Ngrok&logoColor=white)

### | State Management

![Static Badge](https://img.shields.io/badge/Jotai-dimgray.svg?logo=data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyLjllbSIgaGVpZ2h0PSIxZW0iIHZpZXdCb3g9IjAgMCA1MTIgMTc3Ij48cGF0aCBkPSJNNzQuOTk3IDkuNDA1aDM0LjQ1M3YxMTQuOTJhNTIuMTYgNTIuMTYgMCAwIDEtNy4wODIgMjcuNjM3YTQ4LjE0IDQ4LjE0IDAgMCAxLTE5Ljc5NCAxOC4xMTJhNjQuMiA2NC4yIDAgMCAxLTI5LjM3MiA2LjM5MmE2Ni41IDY2LjUgMCAwIDEtMjctNS4zMTJhNDMgNDMgMCAwIDEtMTkuMTItMTYuMDkzUTAgMTQ0LjI3OSAwIDEyNy44NjZoMzQuNjgzYy4xMDcgNi41MzMgMiAxMS42MzIgNS42ODMgMTUuMjQ0YTE5Ljg1IDE5Ljg1IDAgMCAwIDE0LjYwNyA1LjQzNXExOS44NjQgMCAyMC4wMjQtMjQuMjJ6bTExMC45MDEgMTY3LjIycS0xOC43NSAwLTMyLjM4MS04LjAwM2E1NC4wNyA1NC4wNyAwIDAgMS0yMS4wNTEtMjIuMzc4YTcxLjc0IDcxLjc0IDAgMCAxLTcuNC0zMy4zNTZhNzIuMTUgNzIuMTUgMCAwIDEgNy40LTMzLjUxNWE1NC4yIDU0LjIgMCAwIDEgMjEuMDUtMjIuMzc4YTYyLjkgNjIuOSAwIDAgMSAzMi4zODItOC4wMDNhNjMgNjMgMCAwIDEgMzIuNCA4LjAwM2E1NC4xIDU0LjEgMCAwIDEgMjEuMDMzIDIyLjM3OGE3Mi4xNiA3Mi4xNiAwIDAgMSA3LjQxOCAzMy41MTVhNzEuNzQgNzEuNzQgMCAwIDEtNy40MTggMzMuMzU2YTU0IDU0IDAgMCAxLTIxLjAzMyAyMi4zNzhxLTEzLjY1IDguMDItMzIuNCA4LjAwM20zOS4xOTgtMTY3LjIydjE4LjU5aC03OC4zNzhWOS40MDV6bS0zOC45NSAxNDAuNjYzYTIxLjI1IDIxLjI1IDAgMCAwIDE4Ljk4NS0xMC4xMjZsLjI5Ni0uNDk3cTYuNTUtMTAuNjIyIDYuNTUtMjYuNzg3cTAtMTUuNjI1LTYuMTctMjYuMTIybC0uNDM0LS43MThhMjEuMjUgMjEuMjUgMCAwIDAtMTkuMjgtMTAuNjIzYTIxLjUxIDIxLjUxIDAgMCAwLTE5LjE4MiAxMC4xMzdsLS4yOTMuNDg2cS02LjYwNCAxMC42MjMtNi42MDQgMjYuODRxMCAxNS42NzYgNi4xNzEgMjYuMDc2bC40MzMuNzExYTIxLjUzIDIxLjUzIDAgMCAwIDE4Ljg2IDEwLjYzOXptMTQzLjY5LTk5LjQ2NHYyNS43NmgtMjMuMjYzdjU5Ljk0N3EwIDcuMDgzIDMuMjIyIDkuNTYxYTEzLjI4IDEzLjI4IDAgMCAwIDcuODE0IDIuNTFsLjU2LS4wMTRhMjYgMjYgMCAwIDAgNC44MTYtLjQ0MmwzLjctLjY3M2w1LjMxMiAyNS41MTJsLTEuMzIyLjM4NWMtMS41NzYuNDQ0LTMuNTIzLjk0Ny01LjkyIDEuNDkyYTYwLjQgNjAuNCAwIDAgMS0xMC4wNzcgMS4yODdsLTEuMjcxLjA0cS0xOC42NzkuODMzLTI5Ljk3NC04LjA3MnEtMTEuMDQtOC43MDQtMTEuMTM4LTI2LjMzNGwuMDAyLTY1LjJoLTE2LjkwOHYtMjUuNzZoMTYuOTA4di0yOS42MmgzNC4yNzZ2MjkuNjJ6bTUyLjU4MyAxMjUuOTVxLTE3LjcwNCAwLTI5LjM3Mi05LjI2dC0xMS42NjctMjcuNnEwLTEzLjgyOSA2LjUxNS0yMS43MjRhMzcuNSAzNy41IDAgMCAxIDE3LjEwMy0xMS41NjJhOTcgOTcgMCAwIDEgMjIuNzMzLTQuNzhhMTc0LjUgMTc0LjUgMCAwIDAgMjMuMDE2LTMuMzgxcTYuOTQtMS43NyA2LjkyMi03Ljcydi0uNDk1Yy4yNi00LjQ2LTEuNDk1LTguOC00Ljc4LTExLjgyN3EtNC44MTUtNC4xNi0xMy41NjItNC4xNzhhMjQuMzggMjQuMzggMCAwIDAtMTQuNzMgNC4wMTlhMTguOTQgMTguOTQgMCAwIDAtNy4yNDEgMTAuMjE1bC0zMS43MDktMi41NjdhNDIuMjggNDIuMjggMCAwIDEgMTcuNTgtMjYuODA1cTE0LjA1OC05Ljg3OSAzNi4yNi05Ljg5N2E3NC44IDc0LjggMCAwIDEgMjUuNzQyIDQuMzU2YTQyLjgzIDQyLjgzIDAgMCAxIDE5LjM2OSAxMy41NjFxNy4zNjUgOS4yMjUgNy4zNjUgMjMuOTM3djgzLjM3MWgtMzIuNTA2di0xNy4xMzhoLS45NTZhMzUuNzMgMzUuNzMgMCAwIDEtMTMuNDkgMTQuMDRxLTguOTc3IDUuNDM1LTIyLjU5MiA1LjQzNW05LjgwOS0yMy42NzFhMjYuNTYgMjYuNTYgMCAwIDAgMTguNTE5LTYuNTVhMjEuMTQgMjEuMTQgMCAwIDAgNy4yNDItMTUuNjY3bC0uMDAxLTEzLjc0MWEyMC4yIDIwLjIgMCAwIDEtNi4yMzIgMi40MDhhMTAxIDEwMSAwIDAgMS05LjAzIDEuNzdsLTMuMDgzLjQ3NGMtMS45NzYuMzExLTMuNzk4LjYwNi01LjQ4NS44NTRhMzQgMzQgMCAwIDAtMTQuNTE4IDUuMDgxYTEyLjUgMTIuNSAwIDAgMC01LjUwNiAxMS4wMTNhMTIuMjkgMTIuMjkgMCAwIDAgNS4wOTkgMTAuNjIyYTIyIDIyIDAgMCAwIDEyLjI1MyAzLjc0NnptMTAxLjc5LTExOC4yMTJsLS42MDgtLjAwMmExOC40MyAxOC40MyAwIDAgMS0xMy4wNDktNS4xMTZhMTYuMTggMTYuMTggMCAwIDEtNS40Ny0xMi4yN2ExNi4xIDE2LjEgMCAwIDEgNS40Ny0xMi4yMzNjNy40MjQtNi43MzMgMTguNzQ0LTYuNzMzIDI2LjE2OCAwYTE2LjEgMTYuMSAwIDAgMSA1LjQ3IDEyLjIzM2ExNi4xOCAxNi4xOCAwIDAgMS01LjA1NiAxMS44OWwtLjQxNC4zOGExOC41IDE4LjUgMCAwIDEtMTIuNTEgNS4xMThtLTE3Ljc2NCAxMzkuNTQ2VjUwLjYwNGgzNC4yNzZ2MTIzLjYxM3oiLz48L3N2Zz4=&style=for-the-badge&logoColor=black)
<br><br><br>

# Contents

- [🧲 Motivation](#-motivation)
- [✨ Features](#-features)
  - [(1) 브라우저 액션 팝업](#1-브라우저-액션-팝업)
  - [(2) 스크롤 이벤트 동기화](#2-스크롤-이벤트-동기화)
  - [(3) 클릭 이벤트 동기화](#3-클릭-이벤트-동기화)
  - [(4) 실시간 음성 채팅](#4-실시간-음성-채팅)
  - [(5) 공유 캔버스](#5-공유-캔버스)
- [🔥 Challenge](#-challenge)
  - [1. Web 🆚 Chrome Extention](#web--chrome-extention)
  - [2. WebSocket을 이용한 실시간 동기화](#websocket을-이용한-실시간-동기화)
    - [roomId를 포함한 이벤트를 서버로 전송](#1-roomId를-포함한-이벤트를-서버로-전송)
    - [전송받은 roomId와 동일한 공간에만 이벤트를 전송](#2-전송받은-roomId와-동일한-공간에만-이벤트를-전송)
  - [3. 스크롤 이벤트 동기화](#스크롤-이벤트-동기화)
    - [2-1. 픽셀로 적용한 스크롤 적용하기](#1-픽셀의-양으로-스크롤-적용하기)
    - [2-2. 백분율로 적용한 스크롤 적용하기](#2-백분율을-기준으로-스크롤-적용하기)
  - [4. 클릭 이벤트 동기화](#클릭-이벤트-동기화)
    - [3-1. 절대 좌표로 적용한 클릭 적용하기](#1-절대-좌표를-이용한-클릭-적용하기)
    - [3-1. 상대 좌표와 UR을 이용한 클릭 적용하기](#2-상대-좌표와-url을-이용한-클릭-적용하기)
  - [5. 실시간 음성 채팅](#실시간-음성-채팅)
    - [5-1. WebRTC를 이용한 음성 채팅](#1-webrtc를-이용한-음성-채팅)
    - [5-2. Web Audio API를 통한 음성 제어](#2-web-audio-api를-통한-음성-제어)
  - [6. 공유 캔버스](#공유-캔버스)
    - [6-1. Canvas API를 활용한 실시간 드로잉](#1-canvas-api를-활용한-실시간-드로잉)
    - [6-2. requestAnimationFrame을 활용한 페이드 아웃 애니메이션 구현](#2-requestanimationframe을-활용한-페이드-아웃-애니메이션-구현)
    - [6-3. 상대 좌표 시스템을 이용한 드로잉 적용](#3-상대-좌표-시스템을-이용한-드로잉-적용)
- [💭 Memoir](#-memoir)
- [🗓️ Schedule](#️-schedule)
  <br><br><br>

# 🧲 Motivation

Gong-Gan 프로젝트는 화면 공유에서 더 나아갈 수 없을까? 하는 의문에서 시작되었습니다.<br>
<br>

1. 화면 공유는 많은 경우에 편리하지만, 중요한 개인 정보를 포함한 페이지를 공유할 때는 상대방에게 민감한 데이터를 보여주고 싶지 않은 경우도 있다고 생각했습니다.<br>
   <br>
2. 화면 공유를 통해 다른 사람과 협업하거나, 친구와 소통 할 때 <br>
   "스크롤 조금만 내려봐", "여기 클릭해 봐"와 같은 요청을 주고받는 과정에서 "어디? 여기?"와 같은 소통이 잘되지 않는 답답함을 자주 느꼈습니다. 직접 조작할 수 없는 상황에서는 효과적인 소통과 협업이 어려웠습니다.<br><br>

위와 같은 이유로 "화면을 공유하지 않고도 다른 사람들과 어떻게 원활하게 협업할 수 있을까?"라는 고민을 하게 되었습니다. 이러한 고민 끝에, 로컬 브라우저에서 다른 사용자와 실시간으로 상호작용을 하고 다양한 기능을 제공하는 프로젝트를 시작하게 되었습니다.<br>

<br><br><br>

# ✨ Features

### 1. 브라우저 액션 팝업

1-1 공간 생성

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfMTA0/MDAxNzIzMDU1NDU0ODgx.4xQDUKA4kwYG81sBdq5LvC_sW-nr8J1FoMSKZiPGeXgg.ynMOmnhhoXlfnjVGowyF3hM8Qa5zqgBh89mNAniozS0g.GIF/%EB%B0%A9_%EC%83%9D%EC%84%B1.gif?type=w3840" width="600">
</p>
<br>

- 공간 생성 버튼을 클릭하면 무작위로 부여 된 방 번호와 상호 작용이 필요한 url 입력을 통해 공간을 생성할 수 있습니다.
  <br><br>

1-2 사용자 초대 및 참여하기

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfMTkg/MDAxNzIzMDU0OTU1NTM1.b2gZgIRVKvUr-SpgrewHV_pkbCRIN7Wg__4BN9uIeUAg.V1KJsYh2_tLzUPSbgmT36Bz3XuuNpvni3TFZSPUaR9Ug.GIF/%EC%B0%B8%EC%97%AC%ED%95%98%EA%B8%B0.gif?type=w3840" width="600">
</p>
<br>

- 공간에 접속 중인 사용자는 방 번호 복사 버튼을 이용하여 현재 접속 중인 방 번호를 복사할 수 있습니다.
- 참여하기 버튼을 클릭하면 공간에 접속 중인 사용자에게 받은 방 번호를 통해 다른 사용자가 만든 공간에 참여할 수 있습니다.
  <br><br>

### 2. 스크롤 이벤트 동기화

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfMjY1/MDAxNzIzMDU3MzU5NDk1.Ksf5F47C9Y3819eA0m9_LA52j-N03woN9DD51n2U6dYg.ng9-_v5iybKkHtYgyR-pM2kJpVWXY7Vy6rOd4rT4O3Ag.GIF/%EB%B0%B1%EB%B6%84%EC%9C%A8_%EC%8A%A4%ED%81%AC%EB%A1%A4.gif?type=w3840" width="600">
</p>
<br>

- 같은 공간에 접속한 사용자는 항상 같은 스크롤 위치의 화면을 볼 수 있습니다.
- 사용자가 iframe 화면을 스크롤 하면 다른 사용자에게도 스크롤 이벤트가 적용됩니다.
  <br><br>

### 3. 클릭 이벤트 동기화

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfMjcw/MDAxNzIzMDU3MzU5MzA2.B4JpMYBx1Ln7F2_e-sKqt6MnhCouAV6z84eFUaBJQgUg.W34wXFk5wLtIyX0qNdNl591CYa3b4DCmObnjBOdjO10g.GIF/%EC%83%81%EB%8C%80_%EC%A2%8C%ED%91%9C.gif?type=w3840" width="600">
</p>
<br>

- 같은 공간에 접속한 사용자는 항상 같은 화면을 볼 수 있습니다.
- 사용자가 iframe 화면 안에 로드 된 웹 페이지에서 클릭을 하면 다른 사용자에게도 클릭 이벤트가 적용됩니다.
  <br><br>

### 4. 실시간 음성 채팅

<p align="center">
<a href="https://www.youtube.com/watch?v=jNk2qFmdRTE">
  <img src="https://postfiles.pstatic.net/MjAyNDA4MjJfMjIy/MDAxNzI0MzMxODY2NTA1.1FOwKTmwhCqWNSOwrZZPy9kJ0N2ctB_Ft6ftrAVDre0g.dZl9NN2i6XZ6XjjM2WLmquLIaZOuHDdCv3b0S8hGjx0g.PNG/image.png?type=w773" alt="음성채팅 녹화 영상입니다." width="600">
</a><br>
  이미지를 클릭하면 음성 채팅 유튜브 링크로 이동합니다.
</p>

- 같은 공간에 접속한 사용자와 실시간 대화가 가능합니다.
- 사운드, 마이크 버튼 클릭을 통해 on/off가 가능합니다.
- 사운드, 마이크 버튼 위로 마우스 포인터를 호버 시켜 슬라이더를 통해 음량의 조절이 가능합니다.
  <br><br>

### 5. 공유 캔버스

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfOTMg/MDAxNzIzMDU1NDU0OTE0.soN5qd70GpNIwxwmZsFzVBkxwFNf5Ze6JsVzOn--xm4g.49cRCuRsSBhXYz1ljXWPse3vx-f8ENk5iaBtKAl8U4og.GIF/%EA%B3%B5%EC%9C%A0%EC%BA%94%EB%B2%84%EC%8A%A4.gif?type=w3840" width="600">
</p>
<br>

- 같은 공간에 접속한 사용자와 공유 캔버스 이용이 가능합니다.
- 펜 아이콘을 클릭하여 iframe 화면 위에 그림을 그리면 다른 사용자의 iframe 화면에도 같은 위치에 그림이 그려집니다.
- 색상 선택 버튼을 통해 펜의 색상을 선택하여 그림을 그릴 수 있습니다.
  <br><br><br>

# 🔥 Challenge

## **Web 🆚 Chrome Extention**

<img src="https://postfiles.pstatic.net/MjAyNDA4MjdfMTM4/MDAxNzI0NzQ0NzU1OTI1.Nifg9McT7uw8WQKgjhp_mynjF6vvF-_v-okz0-IXMFcg.xkutqqZ48C28Y2kk3cTfNXxnWuennfyuQnyuiXRyKPEg.PNG/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-08-27_164526.png?type=w773" width="600"><br>
<br>
이는 `X-Frame-Options Header`와 `Content-Security-Policy` 설정으로 인해 발생한 것으로, 해당 설정을 가진 페이지는 iframe 내에서 로드가 불가능합니다.<br>
예를 들어, 네이버(Naver), 구글(Google), 노션(Notion) 등의 페이지는 이러한 이유로 iframe에서 열리지 않았습니다.<br>

이를 우회하여 구현하는 방법을 고려했으나, 이는 프로젝트를 진행하는 과정에서 보안 기준을 위반하는 것이라고 생각했습니다.

<details>
<summary>🤔X-Frame-Options❓</summary>
X-Frame-Options는 웹사이트가 다른 웹페이지에 의해 프레임, 아이프레임, 또는 오브젝트 요소 내에서 로드되는 것을 제어하는 설정입니다. 주로 클릭재킹(clickjacking)이라는 공격을 막기 위해 사용됩니다.<br> 클릭재킹은 사용자가 보이지 않는 버튼을 클릭하도록 유도하여 악의적인 행위를 수행하는 공격입니다.
</details>
<details>
<summary>🤔Content-Security-Policy❓</summary>
Content-Security-Policy (CSP)는 웹사이트가 신뢰할 수 있는 출처에서만 특정 타입의 콘텐츠를 로드하도록 설정하는 보안 정책입니다.<br>
주로 XSS(Cross-Site Scripting)와 같은 공격을 막기 위해 사용됩니다.<br>
XSS는 악의적인 스크립트가 웹페이지에 삽입되어 실행되는 공격입니다.
</details><br>

| 기능                           | 브라우저 확장 프로그램 | 일반 웹사이트 |
| ------------------------------ | ---------------------- | ------------- |
| 네트워크 요청 가로채기 및 수정 | 가능                   | 불가능        |
| 동일 출처 정책 우회            | 가능                   | 불가능        |
| HTTP 헤더 수정                 | 가능                   | 불가능        |
| 컨텐츠 스크립트 실행           | 가능                   | 불가능        |
| 권한                           | 광범위함               | 제한적        |

브라우저 보안 정책으로 인해 일반 웹사이트에서는 특정 URL을 iframe으로 로드하는 것이 불가능 했습니다.<br>
이러한 이유로 웹사이트가 아닌 크롬 확장 프로그램을 사용하는 것이 필요했고, 아래와 같은 크롬 확장 프로그램을 참고했습니다<br>

`Responsive Viewer`
`Ignore X-Frame Headers`<br>

크롬 확장 프로그램을 사용하면 로컬 환경에서 네트워크 요청을 가로채고 수정할 수 있으며, 동일 출처 정책을 우회할 수 있습니다. <br>
또한, HTTP 헤더를 수정하고, 컨텐츠 스크립트를 실행할 수 있는 등, 더 많은 권한을 부여받아 원하는 기능을 구현할 수 있다고 판단하여 크롬 확장 프로그램으로 개발을 진행했습니다.

`rules.json`

```js
"responseHeaders": [
        {
          "header": "Content-Security-Policy",
          "operation": "remove"
        },
        {
          "header": "X-Frame-Options",
          "operation": "remove"
        }
      ]
```

위 코드에서 `X-Frame-Options Header`와 `Content-Security-Policy`를 제거하고 있습니다.

<br>
크롬 확장 프로그램에서 헤더를 제거하는 타이밍은 HTTP 요청/응답 생명주기 중 특정 시점에 발생합니다.
<br><br>
<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfMjEy/MDAxNzIzMDU4MzU5ODI5.10x8c_Jzii7Fg5jn_BCGSENItMHqKIBubB4jy4xUvpMg.8LjDzkvmc_5ZFWjrQEoTN8hQo3U_gAIhTeyTSwn88jog.JPEG/%EC%9B%B9_%ED%8E%98%EC%9D%B4%EC%A7%80_%EC%A0%9C%EA%B1%B0%EA%B7%B8%EB%A6%BC.jpg?type=w773" width="600">
</p>

1. 요청 단계<br>
   사용자가 URL을 입력하거나 링크를 클릭하면 브라우저가 서버에 HTTP 요청을 보냅니다.
   <br><br>
2. 서버 응답<br>
   서버는 요청받은 리소스와 함께 HTTP 응답 헤더를 포함하여 응답합니다. 이 헤더에는 'Content-Security-Policy'와 'X-Frame-Options' 등이 포함될 수 있습니다.
   <br><br>
3. 확장 프로그램 개입<br>
   크롬 확장의 declarativeNetRequest API를 사용한 룰이 이 시점에 적용됩니다. 브라우저가 서버로부터 응답을 받은 직후, 그러나 응답 본문을 처리하기 전에 발생합니다.
   <br><br>
4. 헤더 수정<br>
   설정된 룰에 따라 지정된 헤더('Content-Security-Policy'와 'X-Frame-Options')가 응답에서 제거됩니다.
   <br><br>
5. 응답 처리<br>
   수정된 응답이 브라우저의 렌더링 엔진으로 전달되어 처리됩니다.<br><br>

이 과정을 통해 브라우저는 수정된 헤더를 기반으로 페이지를 렌더링하게 되어, 원래는 iframe 안에 로드되지 않을 웹 페이지가 로드됩니다.
<br><br><br>

## 중복 가능성이 없는 roomId 생성
같은 공간의 사용자들만 이벤트가 공유되는 것이 중요했습니다.<br>
그러기 위해서는 공간 Id의 고유성을 확보하는 것이 필요했고, 고유한 Id 생성을 위해서 2가지 방법을 시도했습니다.

### 1. Math.random을 통한 Id 생성
```js
const randomroomId = Math.random().toString(36).slice(2, 11);
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MjdfNzQg/MDAxNzI0NzQ0NzU1OTMx.oiu53l6HXDryVi52uGqBBdoEGtS-XNbr1VuLPYMFKLgg.f6nlHpLXQe_Jz8gYLY12kRPqg13EpVKP5X-dMekzhi8g.PNG/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-08-27_164421.png?type=w773" width="600">
</p>

처음 시도했던 방식은 `Math.random`메서드를 통해 영문, 숫자가 결합된 랜덤한 roomId를 생성하여 서버에 저장하는 방식으로 구현했습니다.<br>
9자리의 랜덤한 roomId를 생성한다고는 했지만 방 번호가 겹칠 가능성이 없는 것은 아니었습니다.<br>
이미 생성된 roomId에 대한 유효성 검사를 진행하고, 오류 토스트 메시지 팝업이 표시되지만 고유한 Id를 생성하는 것에 초점을 맞췄을 때 고유성이 부족하다고 판단하였습니다.
<br><br>

### 2. Nano Id를 통한 Id 생성
고유한 Id 생성에 초점을 사용을 고려한 라이브러리는 UUID와 Nano Id가 있었습니다.<br>
`UUID`는 매우 높은 고유성을 가지고 있지만 Id의 길이가 길다는 단점이 있었고, `Nano Id`는 높은 고유성과 더불어 Id의 길이도 짧았습니다.<br>
Id의 길이가 짧았을 때 중복 생성 문제가 생기지 않을까 우려했지만, 10억분의 1의 중복 가능성을 가지고 있었기 때문에 고유성을 가질 수 있다고 판단했습니다.

기본적으로 Nano ID는 URL 친화적인 기호( A-Za-z0-9\_-)를 사용하고 21자로 구성된 ID를 반환합니다.

```js
import { nanoid } from "nanoid";
model.id = nanoid(); // "V1StGXR8_Z5jdHi6B-myT"
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MjdfNzQg/MDAxNzI0NzQ0NzU1OTMx.oiu53l6HXDryVi52uGqBBdoEGtS-XNbr1VuLPYMFKLgg.f6nlHpLXQe_Jz8gYLY12kRPqg13EpVKP5X-dMekzhi8g.PNG/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-08-27_164421.png?type=w773" width="600">
</p>

이러한 방식으로 생성한 Id를 통해서 `1-1의 Math.random`메서드를 사용했을 때와 마찬가지의 방식으로 진행됩니다.
`Nano Id`를 통한 랜덤한 Id 생성을 통해 100%는 아니지만 중복 될 확률이 0에 수렴하도록 구현하여 고유성을 확보했습니다.
<br><br><br>

## WebSocket을 이용한 실시간 동기화

같은 공간에 접속한 사용자들만 통신이 가능하게 해야했습니다. Id가 같은 방에 접속한 사용자들에게만 이벤트를 전송하여, 동시에 여러방이 생성되는 상황에도 이벤트를 정확하게 전송해야 했습니다.

### 1. roomId를 포함한 이벤트를 서버로 전송

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MjJfOTQg/MDAxNzI0MzIyODA3MjE4.rxi0UO-trhWglrdxdUYYcKrUut4jrLaOEtUKKluSXXMg.firu2RRx4nM96GWzqOODBqGlFf5OAoNwUOhNMNPepqMg.PNG/image.png?type=w773" width="600">
</p>

```js
const scrollData = {
  type: "scrollUpdate",
  roomId,
  userId,
  ...currentInfo,
};

if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {
  socketRef.current.send(JSON.stringify(scrollData));
}
```

- 이벤트를 전송하는 공간 접속자가 roomId를 포함한 이벤트를 서버로 전송합니다.
  <br><br>

### 2. 전송받은 roomId와 동일한 공간에만 이벤트를 전송

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MjJfMTYx/MDAxNzI0MzE1MTIwNDM4.KOuqaJTKeKZNNnGF7zJjx5_0lEkslbxYlE7BbFcN-UQg.FISB1x4adf_oi5a6Qt6OLvUODj46kBOJZ3V0GZZf6vog.PNG/image.png?type=w773" width="600">
</p>

```js
case "scrollUpdate": {
  const clientInfo = clients.get(ws);
  if (clientInfo) {
    const room = rooms.get(clientInfo.roomId);
    if (room) {
      // roomId에 해당하는 방의 클라이언트들에게 이벤트 전송
    }
  }
  break;
}
```

- 서버는 이벤트를 발생시킨 클라이언트가 보낸 이벤트 데이터와 roomId를 전송받습니다.
- roomId를 판별하고 같은 roomId를 가진 공간에 접속한 사용자에게 이벤트를 전송합니다.

위와 같은 과정을 통해 같은 roomId를 가진 공간의 사용자들만 이벤트의 전달이 가능했고, 같은 공간에 접속한 사용자들만이 이벤트를 주고받아 정확한 이벤트 전달이 가능했습니다.
<br><br><br>

## 스크롤 이벤트 동기화

실시간 스크롤 이벤트 동기화를 적용할 때 가장 중요하게 생각한 점은 같은 공간에 접속한 사용자가 마치 "같은 화면을 보고 있다"고 느끼게 하는 것이었습니다.
<br><br>

### 1. 픽셀의 양으로 스크롤 적용하기<br>

처음 접근한 방식은 스크롤 된 픽셀을 계산하여 다른 사용자에게 전달하였는데, 여기서 문제가 발생했습니다.<br>

### <픽셀로 적용한 스크롤 방식>

```js
const getScrollInfo = (iframe) => {
  const iframeDoc = iframe.contentDocument;
  const { scrollTop, scrollLeft } = iframeDoc.documentElement;

  return {
    top: scrollTop, // 픽셀 단위의 세로 스크롤 위치
    left: scrollLeft, // 픽셀 단위의 가로 스크롤 위치
  };
};
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfNjIg/MDAxNzIzMDU3MzUxODgw.1-FcbkbOhPmhzCwiJa3IQGkyINhTHV1WkcGFoMGzzzgg.5Es7LFTfOdc-hSXwoziQihMqc6dLv70KQocGDL7Orl4g.GIF/%ED%94%BD%EC%85%80%EB%A1%9C_%EC%8A%A4%ED%81%AC%EB%A1%A4.gif?type=w3840" width="600">
</p>
<br>
다른 크기의 화면을 가진 모니터를 사용하거나, 브라우저의 화면 비율이 다르다면 실제로 사용자에게 보이는 내용의 양이 다르다는 점이었습니다.<br>

스크롤 해야 하는 양이 0부터 100까지 있다고 가정했을 때 사용자 1은 100px에 10만큼의 양이 스크롤 되고, 사용자 2는 15만큼의 양이 스크롤 된다고 볼 수 있습니다.<br>

처음 스크롤을 시작했을 때는 얼마 차이 나지 않는다고 생각할 수 있지만 스크롤이 진행될수록 처음엔 5로 시작한 차이가 더 큰 차이를 보이게 될 것이고, 보는 웹 페이지의 내용이 완전히 달라져 소통의 오류가 생길 수 있다고 생각했습니다.
<br><br>

### 2. 백분율을 기준으로 스크롤 적용하기<br>

두번째로 접근한 방식은 스크롤의 전체 길이를 100%로 보고 현재 보고있는 위치를 백분율로 표현하여 다른 사용자에게 전달하는 방법을 사용했습니다.<br>

#### <백분율로 적용한 스크롤 방식>

```js
const getScrollInfo = (iframe) => {
  const iframeDoc = iframe.contentDocument;
  const { scrollTop, scrollLeft, scrollHeight, scrollWidth, clientHeight, clientWidth } =
    iframeDoc.documentElement;

  return {
    verticalRatio: scrollHeight > clientHeight ? scrollTop / (scrollHeight - clientHeight) : 0,
    horizontalRatio: scrollWidth > clientWidth ? scrollLeft / (scrollWidth - clientWidth) : 0,
  };
};
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfMjY1/MDAxNzIzMDU3MzU5NDk1.Ksf5F47C9Y3819eA0m9_LA52j-N03woN9DD51n2U6dYg.ng9-_v5iybKkHtYgyR-pM2kJpVWXY7Vy6rOd4rT4O3Ag.GIF/%EB%B0%B1%EB%B6%84%EC%9C%A8_%EC%8A%A4%ED%81%AC%EB%A1%A4.gif?type=w3840" width="600">
</p>
<br>
이 방식으로 접근한 이유는 스크롤의 전체 길이가 달라진다고 해도 백분율로 접근하게 되면 사용자 1이 10%의 지점으로 스크롤을 했을 때, 사용자 2도 10%의 지점으로 스크롤 된다고 생각했습니다.<br>

픽셀의 양으로 적용하는 방법과 가장 큰 차이점은 같은 10%가 스크롤 되어도 화면의 크기나 비율에 따라 적용되는 픽셀의 양이 다르기 때문에 같은 위치의 화면을 보고 소통할 수 있다는 것이었습니다.
<br><br><br>

## 클릭 이벤트 동기화

실시간 클릭 이벤트 동기화를 적용할 때 가장 중요하게 생각한 점은 같은 공간에 접속한 사용자가 마치 "같은 화면을 보고 있다"고 느끼게 하는 것이었습니다.

### 1. 절대 좌표를 이용한 클릭 적용하기<br>

처음 접근한 방식은 클릭된 위치의 절대 좌표를 계산하여 다른 사용자에게 전달하였는데, 여기서 문제가 발생했습니다.

#### <절대 좌표로 적용한 클릭 동기화 방식>

```js
function handleClick(event) {
  const clickData = {
    type: "clickEvent",
    roomId,
    userId,
    x: event.clientX,
    y: event.clientY,
  };
  socketRef.current.send(JSON.stringify(clickData));
}
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfMjM3/MDAxNzIzMDU3MzUxNDk5.qWFqb-YhcCqLeXt-2P5CIwpitBJIZEp-up1h_wDyyyog.IQw3UI4M8LJjRSyTooSO_BPCVzd7iZKtF-keA_uLdn0g.GIF/%EC%A0%88%EB%8C%80_%EC%A2%8C%ED%91%9C.gif?type=w3840" width="600">
</p>
<br>
다른 크기의 화면을 가진 모니터를 사용하거나, 브라우저의 화면 비율이 다르다면 동일한 절대 좌표가 서로 다른 위치를 가리키게 된다는 점이었습니다.<br>

예를 들어, (100, 100) 좌표가 사용자 1의 화면에서는 버튼 중앙을 가리키지만, 사용자 2의 화면에서는 전혀 다른 위치를 가리킬 수 있습니다.<br>

그렇게 된다면 서로 다른 컨텐츠를 클릭하게 되어 클릭 이벤트를 발생시킨 사용자의 의도와는 다르게 다른 사용자에게 적용될 수 있다고 생각했습니다.
<br><br>

### 2. 상대 좌표와 URL을 이용한 클릭 적용하기<br>

두번째로 접근한 방식은 클릭 위치를 상대 좌표로 변환하고, 현재 페이지의 URL도 함께 전송하는 것이었습니다.

#### <상대 좌표를 이용한 클릭 동기화 방식>

```js
function handleClick(event) {
  const iframe = iframeRef.current;
  const relativeX = event.clientX / iframe.clientWidth;
  const relativeY = event.clientY / iframe.clientHeight;

  const clickData = {
    type: "clickEvent",
    roomId,
    userId,
    relativeX,
    relativeY,
    iframeWidth: iframe.clientWidth,
    iframeHeight: iframe.clientHeight,
    url: iframe.contentWindow.location.href,
  };
  socketRef.current.send(JSON.stringify(clickData));
}
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MDhfMjcw/MDAxNzIzMDU3MzU5MzA2.B4JpMYBx1Ln7F2_e-sKqt6MnhCouAV6z84eFUaBJQgUg.W34wXFk5wLtIyX0qNdNl591CYa3b4DCmObnjBOdjO10g.GIF/%EC%83%81%EB%8C%80_%EC%A2%8C%ED%91%9C.gif?type=w3840" width="600">
</p>
<br>
이 방식으로 접근한 이유는 상대 좌표를 사용함으로써, 화면 크기에 상관없이 동일한 비율의 위치를 클릭할 수 있다고 생각했습니다.<br>

예를 들어, 화면의 정중앙을 클릭했다면 모든 사용자의 화면에서 정중앙이 클릭됩니다.<br>
<br>

#### <URL을 이용한 클릭 동기화 방식>

URL의 변경을 감지하는 방법은 다음과 같습니다.
`popstate`와 `MutationObserver`을 이용했습니다.
 
<details>
<summary>🤔popstate란❓</summary>

`popstate` 이벤트는 브라우저의 세션 기록(히스토리 스택)에 변화가 있을 때 발생하는 이벤트입니다.<br>
사용자가 브라우저의 뒤로 가기, 앞으로 가기 버튼을 눌러 페이지의 상태가 변경될 때 감지하기 위해 사용됩니다.

</details>
<details>
<summary>🤔MutationObserver란❓</summary>

`MutationObserver` 웹 페이지의 구조에 변화를 감지합니다.<br>
DOM에서 발생하는 변화를 비동기적으로 감지하는 객체로 특정 요소에 자식 노드가 추가되거나 삭제되는 등 DOM 구조가 변할 때 이를 감지하기 위해 사용됩니다.

</details><br>

```js
const handleUrlChange = useCallback(
      lastUrlRef.current = newUrl;

      if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {
        const message = JSON.stringify({
          type: "urlChange",
          roomId,
          userId,
          url: newUrl,
        });
        socketRef.current.send(message);
      }
    [roomId, userId],
  );
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA5MDZfMTE2/MDAxNzI1NjA5NDQyMDY1._oBI7rMlezvopx0H0fdS5nLJpkJgsVQ1cmgGjloz4fsg.lkmOVKRQ1UzfQ6w9QdPOH8p_AssM4ruM1xquPJ9Ovs4g.PNG/image.png?type=w773" width="600">
</p>

`MutationObserver`나 `popstate` 이벤트 리스너가 변화를 감지하면, handleUrlChange 함수가 호출됩니다.<br>
이 함수는 현재 URL과 이전에 저장된 URL을 비교하여 변경이 있을 경우에만 서버로 새로운 URL 정보를 전송합니다.<br>
이를 통해 불필요한 데이터 전송을 방지하고 효율적인 동기화를 가능하게 합니다.

#### 1. URL 동기화<br>

- handleUrlChange 함수는 iframe의 URL 변경을 감지합니다.
- 현재 URL과 이전 URL을 비교하여 변경이 있을 경우에만 서버로 새 URL 정보를 전송합니다.
  이를 통해 모든 사용자가 동일한 페이지를 볼 수 있도록 합니다.

#### 2. 클릭 이벤트 동기화<br>

- 클릭 이벤트 발생 시, 다음 정보를 서버로 전송합니다<br>

  - 클릭한 상대 좌표 (relativeX, relativeY)<br>
  - 현재 iframe의 크기 (iframeWidth, iframeHeight)<br>
  - 현재 URL (handleUrlChange 함수를 통해 전송)<br>

  이 정보를 통해 다른 사용자들의 화면에서도 동일한 위치에 클릭 효과를 표시할 수 있습니다.

#### 3. 동기화 우선순위<br>

- URL 변경과 클릭 이벤트가 동시에 발생할 경우(예: 새 페이지로 이동하는 링크 클릭), URL 변경이 먼저 적용됩니다.<br>
- 다른 사용자들의 화면은 먼저 새 페이지로 이동한 후에 클릭 이벤트가 시각화됩니다.

#### 4. 크로스 브라우저 호환성<br>

- iframe의 크기 정보를 함께 전송함으로써, 서로 다른 화면 크기나 해상도를 가진 사용자들 간에도 정확한 클릭 위치를 표시할 수 있습니다.
  <br><br>

이러한 방식을 통해 사용자들은 화면 크기나 해상도에 관계없이 동일한 요소를 클릭하고 있다는 느낌을 받을 수 있고, URL 동기화를 통해 모든 사용자가 항상 동일한 페이지를 보면서 협업할 수 있습니다.
<br><br><br>

## 실시간 음성 채팅

함께 있지 않은 사용자와 소통을 위해 개발을 시작한 프로젝트인 만큼 음성 채팅은 가장 중요한 부분 중 하나라고 생각했습니다.<br>
이를 위해 WebRTC 음성 채팅을 구현하고 Web Audio API를 활용하여 볼륨 조절을 구현했습니다.

### 1. WebRTC를 이용한 음성 채팅

WebRTC(Web Real-Time Communication)는 웹 브라우저 간 플러그인 없이 직접 통신할 수 있게 해주는 기술입니다.

- 낮은 지연 시간: 서버를 거치지 않고 사용자 간 직접 연결되어 대화가 실시간으로 이루어집니다.
- 높은 음질: P2P 연결을 통해 고품질의 오디오를 전송할 수 있습니다.
  <br>

<details>
<summary>🤔P2P란❓</summary>
P2P는 "Peer-to-Peer"의 약자로, 사용자가 서로 직접 연결되어 데이터를 주고받는 방식을 의미합니다.<br>
서버의 개입 없이 각 사용자가 독립적으로 서로 데이터를 주고받습니다.
</details>
<details>
<summary>🤔RTCPeerConnection이란❓</summary>
RTCPeerConnection은 WebRTC에서 피어 간에 오디오, 비디오, 데이터 등을 주고받기 위해 사용하는 핵심입니다.<br>
P2P 연결을 설정하고 관리하며, 데이터를 주고받는 역할을 합니다.
</details><br>

RTCPeerConnection이라는 객체를 만들어 사용자들 사이의 연결을 설정합니다. 이 과정은 같은 공간에 있는 사용자의 전화 선을 연결하는 것과 같습니다.

```js
const peerConnection = new RTCPeerConnection({
  iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
});

localStream.getTracks().forEach((track) => peerConnection.addTrack(track, localStream));
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MjdfMTE2/MDAxNzI0NzYzMTI1ODM0.HBCbieM4Y-jOKAYrWBfURa12WQzfpZjbSC2aMDtXqH8g.9x2rkUGEZgkpxY5nfRA9j4MqM89jv5GnfoTlfTAN0vgg.PNG/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-08-27_203803.png?type=w773" width="600">
</p>
연결 과정은 아래와 같이 진행됩니다

- Offer/Answer 교환: 연결을 시작하는 쪽에서 Offer(보내는 쪽)를 생성하고, 상대방이 이를 받아 Answer(받는 쪽)를 생성합니다.
- 연결 설정: 교환된 정보를 바탕으로 P2P 연결을 설정합니다.

연결이 완료되면 사용자 간에 직접 음성 데이터를 전송하는 것이 가능하고, 이를 통해서 실시간으로 대화가 가능합니다.
<br><br>

### 2. Web Audio API를 통한 음성 제어

실시간 음성 채팅이 가능하도록 하는 것은 성공했지만, 이용자가 원하는 마이크와 사운드의 볼륨이 다를 수 있기 때문에 볼륨의 조절이 가능해야 했습니다.<br>
오디오 볼륨을 조절할 수 있는 노드인 `GainNode`를 사용하여 구현했습니다.

<details>
<summary>🤔Web Audio API란❓</summary>
브라우저에서 오디오를 생성, 처리, 제어할 수 있도록 해주는 도구입니다.<br>
오디오 노드로 구성된 그래프를 만들어 데이터를 조작하거나, 볼륨 조절 작업을 처리할 수 있습니다.
</details>
<details>
<summary>🤔GainNode란❓</summary>
오디오의 볼륨을 조절하는 노드입니다. `GainNode`는 소리 신호의 크기를 조절하는데 사용됩니다.<br>
예를 들어, 마이크 입력 음량이나 재생되는 음량을 제어할 때 사용합니다.
</details>
<br>

#### 1. 입력된 소리를 GainNode에 연결

```js
source.connect(gainNodeRef.current);
gainNodeRef.current.connect(destination);
```

- 마이크에서 입력된 소리를 `GainNode`에 연결합니다.

#### 2. GainNode를 사용하여 볼륨 조절

```js
function setMicGain(micVolumeValue) {
  if (gainNodeRef.current) {
    const gain = (micVolumeValue / 100) ** 3;
    gainNodeRef.current.gain.setValueAtTime(gain, audioContextRef.current.currentTime);
  }
}
```

<div align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MjdfMSAg/MDAxNzI0NzYyNDYyNDk4.lwRnbQTxpa6YS81kL8ufsA9AEq-1EFtj7z8SKKouOWsg.kSS-ZEBN0ox7iahNU9vXMOY9f9HpUc8QqeyJdDGDblIg.PNG/image.png?type=w773" width="218">
<img src="https://postfiles.pstatic.net/MjAyNDA4MjdfMTAg/MDAxNzI0NzYzODU3MjE2.EaVDWNHqW8xZ7qMW6xIQzj7g38Ph52ItxNNrx_0C2Hcg.seaaVb0rYUGmnIAjrut0bKUsaRjO-IYxkAFqDr4DWB8g.PNG/image.png?type=w773" width="200">
</div>

- 사운드 바를 통해 마이크나, 사운드의 볼륨을 조절하면 `setMicGain` 함수 내에서 사운드 바의 조정에 따라 볼륨이 조절됩니다.

#### 3. 볼륨 조절을 거친 후 사용자에게 전달

```js
const destination = audioContextRef.current.createMediaStreamDestination();
gainNodeRef.current.connect(destination);
```

- 마이크의 입력 소리가 다른 사용자에게 전달되기 전에 볼륨 조절을 거치게 됩니다.

이 과정을 통해 조정된 마이크 입력이나 사운드 출력이 WebRTC를 통해 사용자에게 전달됩니다.
<br><br><br>

## 공유 캔버스

음성 채팅과 더불어서 소통할 때 꼭 필요하다고 생각한 것이 함께 그림을 그리고 공유할 수 있는 캔버스 기능이었습니다.<br>
펜 기능을 통해 표시하고 싶은 부분에 선을 긋거나 글씨를 쓰는 등 여러가지 방법으로 소통할 수 있기 때문에 빼놓을 수 없는 기능이라고 생각했습니다.

### 1. Canvas API를 활용한 실시간 드로잉

Canvas API는 HTML5에서 제공하는 캔버스 기능입니다.<br>
`canvas`요소를 사용해 그림을 그릴 수 있는 캔버스를 생성할 수 있습니다.

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MzBfMjQx/MDAxNzI1MDE5ODE4MTA0._U4AWBNpcW-38Cpm06nJP6Ed6fQ5mfu46GHR5YIpqZEg.vRagSpoAfe9624W6RzdmxiWfjy9vdogNLv6J3Jykvicg.PNG/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-08-30_210154.png?type=w773" width="400">
<p align="center">비활성화 상태인 펜 아이콘을 클릭하여 캔버스 기능을 활성화 시킵니다.</p>
</p>
<br>
<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MzBfMjE3/MDAxNzI1MDIwMDI3ODQ0.svpDFUw84blxQDayu23Q7NkWSByhYorqF03VxemJAIYg.T1g2TS9VVhWac2FFGB6oNquq4iTk8zvH2uMFDk0-2Bog.PNG/image.png?type=w773" width="600">
</p>
<p align="center">캔버스 기능이 활성화 되면 iframe 전체 화면을 차지하는 보이지 않는 캔버스가 생기게 됩니다.</p>
<br>

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MzBfMjQ3/MDAxNzI1MDE5ODE4MTA3.1BFtnG8UJY86SYGRED4WtQoW5uxUJ1sxTan_kmVjjgAg.-J5ovXLhwENwbQRZYAJGuMadTZrgMh-MEdJAFQN44Awg.PNG/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-08-30_210708.png?type=w773" width="400">
</p>
<p align="center">펜 색상 선택 기능을 통해 원하는 색 선택이 가능합니다.</p>
<br>
<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MzBfNTkg/MDAxNzI1MDIwNjM1NTIz.L1TNiS3P7AJ-gjPzpk6pqMRPYXxnDbTNmC9pvzn8GsIg.bu3sGtjNwsw9R7PSToyWVc-4wXi48yQXpfHInJGZNLcg.GIF/%ED%99%94%EB%A9%B4_%EB%85%B9%ED%99%94_%EC%A4%91_2024-08-30_211850.gif?type=w3840" width="600">
</p>
<p align="center">캔버스가 활성화 된 상태라면 iframe 위에 자유롭게 그림을 그리는 것이 가능합니다.</p>

#### 캔버스를 관리하기 위해 선 하나를 최소 단위로 정하고 관리합니다.

```js
{
  id: string,
  points: [{x: number, y: number}],
  color: string,
  opacity: number
}
```

1. `mousedown` 이벤트로 그리기 시작을 감지합니다.
2. `mousemove` 이벤트로 선의 경로를 추적합니다.
3. `mouseup` 또는 `mouseleave` 이벤트로 그리기 종료를 감지합니다.

위 과정을 통해 선 하나가 완성되면 고유 ID, 점 배열, 색상, 불투명도 정보를 가진 채로 line Ref 배열에 저장하는 방식으로 선 하나하나를 따로 관리하고 저장합니다.
<br><br>

### 2. requestAnimationFrame을 활용한 페이드 아웃 애니메이션 구현

그려진 선이 자동으로 사라지지 않으면 사용자가 매번 수동으로 지워야 하는 번거로움이 있다고 생각했습니다.<br>
특히 음성 채팅 기능을 지원하는 Gong-Gan의 특성상, 그려진 선이 계속 화면에 남아있을 필요성이 크지 않다고 판단했고, 이에 따라 선이 자동으로 사라지는 기능을 구현했습니다.

선이 갑자기 사라지는 대신 부드럽게 페이드 아웃되는 애니메이션을 적용함으로써 다음과 같은 이점을 얻을 수 있었습니다:

#### 1. **향상된 사용자 경험**<br>

- 선이 서서히 사라짐으로써 사용자에게 더 자연스럽고 부드러운 시각적 경험을 제공합니다. 이는 갑작스러운 변화로 인한 시각적 불편함을 줄여줍니다.

#### 2. **정보의 연속성 유지**<br>

- 페이드 아웃 과정 동안 사용자는 이전에 그려진 내용을 잠시 더 볼 수 있어, 대화의 맥락을 유지하는 데 도움이 됩니다.

#### 3. **시스템 동작에 대한 명확한 피드백**<br>

- 사용자는 그려진 선이 의도적으로 제거되고 있음을 명확히 인지할 수 있습니다. 이는 시스템의 동작을 더 잘 이해하고 예측할 수 있게 해줍니다.

```js
const startFadeOut = useCallback(
  (lineId) => {
    setTimeout(() => {
      const startTime = performance.now();
      const duration = 1000; // 1초 동안 페이드 아웃

      requestAnimationFrame(fade);
    }, 1000); // 1초 후 페이드 아웃 시작
  },
  [redrawCanvas],
);
```

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MzBfMTA0/MDAxNzI1MDIwNzc4ODg5.LgS0AGnlhUQCO1lfH7Rku9UR0gP5sfJBt8EDurN8nSIg.IyuisVxEOAQCrsMciH7BDnRiZ7pNvokx_xrLNJE-sk4g.GIF/%ED%99%94%EB%A9%B4_%EB%85%B9%ED%99%94_%EC%A4%91_2024-08-30_211850_(1).gif?type=w3840" width="600">
</p>

`startFadeOut` 함수를 통해 페이드 아웃을 구현했습니다.

페이드 아웃이 적용되는 방식은 아래와 같습니다.

1. 선이 그려진 후 1초 뒤 페이드 아웃이 시작됩니다.
2. 1초 동안 선명한 선이 유지된 뒤 1초간 서서히 선이 사라집니다.

선이 사라져서 투명도를 나타내는 `opacity`의 수치가 0이 되어 선이 완전 사라지면 `lineRef` 배열에서 제거되어 선이 완전히 사라지게 됩니다.
<br><br>

### 3. 상대 좌표 시스템을 이용한 드로잉 적용

이 방식으로 접근한 이유는 상대 좌표를 사용함으로써, 드로잉 하고 싶은 위치를 화면 크기에 상관없이 같은 위치에 그려질 것이라고 생각했습니다.

**보내는 쪽**: iframe 크기가 800x600

**받는 쪽**: iframe 크기가 1000x750

보내는 쪽의 iframe 내에서 좌측 상단에서 100px 오른쪽, 75px 아래 지점(100, 75)에 점을 찍었다고 가정해 설명하겠습니다.

#### <보내는 쪽 사용자>

```js
const x = 100;
const y = 75;
const relativeX = x / canvas.width = 100 / 800 = 0.125;
const relativeY = y / canvas.height = 75 / 600 = 0.125;
```

1. 실제 그림이 그려지는 좌표를 캔버스의 크기로 나누어서 0과 1 사이의 값으로 변환합니다.
2. 보내는 쪽 사용자는 (0.125, 0.125)라는 상대 좌표를 서버로 전송합니다.

#### <받는 쪽 사용자>

```js
const receivedRelativeX = 0.125;
const receivedRelativeY = 0.125;
const x = receivedRelativeX * canvas.width = 0.125 * 1000 = 125;
const y = receivedRelativeY * canvas.height = 0.125 * 750 = 93.75;
```

1. 받는 쪽에서 (0.125, 0.125)의 값을 서버로부터 전달 받습니다.
2. 받은 좌표를 받는 쪽의 캔버스 크기에 곱하여 실제 픽셀 좌표로 변환하여 (125, 93.75) 위치에 점이 찍히게 됩니다.

<p align="center">
<img src="https://postfiles.pstatic.net/MjAyNDA4MzBfNDkg/MDAxNzI1MDIxNTYyMjc1.piMfP036wKSCs0KXCMqcQ1caxbNp8yhJE6AkVX-a7aQg.OmJEyXqZQNLvUAROFVRwobAR_WpK8dCN57-VURVSgrMg.GIF/%ED%99%94%EB%A9%B4_%EB%85%B9%ED%99%94_%EC%A4%91_2024-08-30_213815.gif?type=w3840" width="600">
</p>

이렇게 함으로써, iframe의 크기나 화면 비율에 관계없이 두 사용자 모두 자신의 iframe 내에서 동일한 상대적 위치(좌상단에서 12.5% 오른쪽, 12.5% 아래)에 점이 찍히는 것을 볼 수 있습니다.

이 원리가 선을 그리는 모든 과정에 적용되어, 서로 다른 iframe 크기를 가진 사용자들 사이에서도 일관된 경험을 제공할 수 있습니다.

사용자들은 자신의 iframe 크기에 맞게 조정된 동일한 그림을 보게 되므로, 마치 같은 캔버스 위에 그림을 그리는 것 같은 경험을 할 수 있습니다.
<br><br><br>

# 💭 Memoir

이번 프로젝트를 진행하면서 많은 양은 아니지만 서버를 접해보고 `WebSocket`을 사용하면서 실시간 양방향 통신 이라는 경험을 할 수 있었던 즐거운 경험이었던 것 같습니다.

Gong-Gan 프로젝트를 진행하면서 크게 2가지의 어려움과 깨달음이 있었습니다.

### 1. WebSocket을 이용한 실시간 통신

실시간으로 데이터를 주고 받기 위해서 `WebSocket`을 사용했지만 비동기 적으로 작동하고, 연결 끊김이나 이벤트를 주고 받는 것에 일관성을 유지하는 것이 생각보다 많은 어려움을 동반한다는 것을 느낀 순간이 많았습니다.<br>

프론트엔드 지식만 가진채로 프로젝트를 진행하면서 서버와의 통신과 서버 측 로직을 이해하는 것이 처음에는 어려웠지만 그 과정에서 클라이언트와 서버 사이의 통신이 어떤식으로 상호작용하는지 조금은 이해할 수 있었고, 새로운 지식을 배우고 경험하는 것이 즐거움으로 다가오는 순간이 많았습니다.

### 2. 사용자 경험을 위한 고민

크롬 확장 프로그램을 이용하는 사용자는 각자 다른 크기와 해상도를 가진 화면으로 사용할 것이고, 편의에 따라 화면의 비율을 조정해서 사용하는 경우가 많다고 생각했지만 생각하는 것과 그것을 고려하여 개발하는 것은 많은 차이가 있다는 것을 느꼈습니다.<br>

모든 상황에 대응하는 것은 짧은 시간내에 구현 가능한 어느정도의 합의점을 찾는 일이 많이 어려웠지만, 그 과정에서 사용자 중심 설계에 대한 중요성을 확실히 깨달을 수 있는 경험이었습니다.

짧은 기간에 생각한 기획을 완벽하게 개발한 프로젝트는 아니라고 생각하지만, 새로운 기술을 경험하고 익혀 생각한 것을 구현하여 뿌듯한 감정이 느껴졌습니다.<br>
추후 이벤트를 전달하는 것에 정확도를 더 많이 올려 사용자가 브라우저를 사용하는 많은 상황에서 필요한 순간 편안하고 원활한 소통이 될 수 있게 하고싶습니다.
<br><br><br>

# 🗓️ Schedule

프로젝트 진행 기간<br>
2024.07.08 ~ 2024.07.30

1주차

- 아이디어 구상
- POC
- 프로젝트 세팅
  <br><br>

2주차

- 확장 프로그램 popup 구현
- iframe에 웹 사이트 실행 구현
- 방 만들기 구현
- 참여하기 구현
- iframe 로드시 웹 사이트 보안 문제 해결
- iframe이 적용된 웹 사이트 정적화면 구현
- 오류 토스트 팝업 구현
  <br><br>

3주차

- 실시간 스크롤 동기화 구현
- 실시간 클릭 동기화 구현
- 실시간 음성 채팅 구현
- 공유 캔버스 구현
